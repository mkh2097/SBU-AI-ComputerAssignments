# -*- coding: utf-8 -*-
"""FinalPopulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14D-lIScWBq__OtCIw5QjwVmtu_RIhJeB
"""

import pandas as pd
import numpy as np

df = pd.read_csv('births-deaths.csv')

df

chinese = df[df.index%4==0]
malays = df[df.index%4==1]
indians = df[df.index%4==2]

import matplotlib.pyplot as plt
def draw(nationality):
  for name in ["live_births", "deaths"]:
    plt.plot(nationality["year"],nationality[name],'*', label=name)
    plt.xlabel('year')
    plt.ylabel(name)
    country = nationality["ethnic_group"].values[0]
    if country.endswith('s'):
      country += '\' '
    else:
      country += '\'s '
    plt.title(country +name +' by year')
    plt.legend()
    plt.show()

draw(chinese)
draw(malays)
draw(indians)

normalized_df = df.copy()
del normalized_df["ethnic_group"]
min_df = normalized_df.min()
max_df = normalized_df.max()
normalized_df=(normalized_df-min_df)/(max_df-min_df)

normalized_df["ethnic_group"] = df["ethnic_group"]
normalized_chinese = normalized_df[df.index%4==0]
normalized_malays = normalized_df[df.index%4==1]
normalized_indians = normalized_df[df.index%4==2]

from sklearn.model_selection import train_test_split

train_chinese, test_chinese = train_test_split(normalized_chinese, test_size=0.1, random_state=42)
train_chinese, val_chinese = train_test_split(train_chinese, test_size=0.1, random_state=42)

train_malays, test_malays = train_test_split(normalized_malays, test_size=0.1, random_state=42)
train_malays, val_malays = train_test_split(train_malays, test_size=0.1, random_state=42)

train_indians, test_indians = train_test_split(normalized_indians, test_size=0.1, random_state=42)
train_indians, val_indians = train_test_split(train_indians, test_size=0.1, random_state=42)

from numpy.random import random
def initialize(degree, pop_number=100):
  init_population = [np.random.uniform(0,1,degree).tolist() for _ in range(pop_number)]
  return np.array(init_population)

import numpy as np
def evaluate(person, values):  
  equation = np.poly1d(person)
  ans = equation(train_chinese["year"])
  # print(equation)
  # print(chinese["year"])
  # print(chinese["live_births"])
  return np.sum(np.power(ans-values, 2)) / len(ans)
  # return np.sum(np.abs(ans-values)) / len(ans)


  #chinese["deaths"].values

def select(population, scores):
  sorted_list = np.array([x for _,x in sorted(zip(scores,population))])
  
  # sorted_list = np.flip(sorted_list, 0)
  return sorted_list[0:10]

np.random.uniform(-1,1)

def mutate(child):
  # print("Before Mutate", child)
  child_mut = child.copy() 
  for i in range(len(child)):
    if np.random.rand() < 0.2:
      alpha = np.random.uniform(0,1)
      if (child_mut[i] + alpha > 1):
        child_mut[i] -= alpha
      elif (child_mut[i] - alpha < -1):
        child_mut[i] += alpha
      else:
        if np.random.rand() < 0.5:
          child_mut[i] += alpha
        else:
          child_mut[i] -= alpha
  # print("After Mutate", child_mut)

  return child_mut

alpha = np.random.uniform(0, 1)
alpha

def crossover(parent_1, parent_2):
  # print("Start crossover:")
  # print(parent_1)
  # print(parent_2)

  child_1 = parent_1.copy()
  child_2 = parent_2.copy()
  if np.random.rand() < 0.95:
    alpha = np.random.uniform(0, 1, 1)
    dis = abs(parent_1-parent_2)


    for i in range(len(parent_1)):
      child_1_set = False
      child_2_set = False

      if parent_1[i] - alpha[0] * dis[i] < -1:
        child_1_set = True
        child_1[i] = parent_1[i] + alpha[0] * dis[i]
      elif parent_1[i] + alpha[0] * dis[i] > 1:
        child_1_set = True
        child_1[i] = parent_1[i] - alpha[0] * dis[i]

    if parent_1[i] + alpha[0] * dis[i] > 1:
      child_2_set = True
      child_2[i] = parent_2[i] - alpha[0] * dis[i]
    elif parent_1[i] - alpha[0] * dis[i]  < -1:
      child_2_set = True
      child_2[i] = parent_2[i] + alpha[0] * dis[i]

    if np.random.rand() < 0.5:
      if not child_1_set:
        child_1[i] = parent_1[i] - alpha[0] * dis[i]
      if not child_2_set:
        child_2[i] = parent_2[i] + alpha[0] * dis[i]
    else:
      if not child_1_set:
        child_1[i] = parent_1[i] + alpha[0] * dis[i]
      if not child_2_set:
        child_2[i] = parent_2[i] - alpha[0] * dis[i]



    
    # child_1_set = False
    # child_2_set = False

    # if (parent_1 - alpha * dis).any() < -1:
    #   child_1_set = True
    #   child_1 = parent_1 + alpha * dis
    # elif (parent_1 + alpha * dis).any() > 1:
    #   child_1_set = True
    #   child_1 = parent_1 - alpha * dis

    # if (parent_2 + alpha * dis).any() > 1:
    #   child_2_set = True
    #   child_2 = parent_2 - alpha * dis
    # elif (parent_2 - alpha * dis).any() < -1:
    #   child_2_set = True
    #   child_2 = parent_2 + alpha * dis

    # if np.random.rand() < 0.5:
    #   if not child_1_set:
    #     child_1 = parent_1 - alpha * dis
    #   if not child_2_set:
    #     child_2 = parent_2 + alpha * dis
    # else:
    #   if not child_1_set:
    #     child_1 = parent_1 + alpha * dis
    #   if not child_2_set:
    #     child_2 = parent_2 - alpha * dis

  # print("Finish crossover:")

  # print(child_1)
  # print(child_2)
  return [child_1, child_2]
# def crossover(parent_1, parent_2):
#   # print("Parent 1 is", parent_1)
#   # print("Parent 2 is", parent_2)
#   child_1, child_2 = parent_1.copy(), parent_2.copy()
#   if np.random.rand() < 0.95:
#     split_point = np.random.randint(1, len(child_1)-2)
#     child_1 = np.append(parent_1[:split_point], parent_2[split_point:])
#     child_2 = np.append(parent_2[:split_point], parent_1[split_point:])
#     # print("Crossover:", [child_1, child_2], "Split point is:", split_point)
#   return [child_1, child_2]



def genetic_algorithm(max_gen, values, degree=4):
  population = initialize(degree)
  gen_counter = 0
  while gen_counter < max_gen:
    gen_counter += 1
    scores = [evaluate(person, values) for person in population]
    population = select(population, scores)
    np.random.shuffle(population)
    children = np.empty(0)
    for i in range(0, 10, 2):
      parent_1, parent_2 = population[i], population[i+1]

      for child in crossover(parent_1, parent_2):
        child = mutate(child)
        # print("NEW CHILD:",child)

        population = np.vstack((population, child))
    population = population.tolist()

    # print("NEW POP:\n", population)

  # print("zero:", evaluate(population[0]))
  # print("last:", evaluate(population[-1]))


  # for x in population[0]:
  #   print(x)

  return population[0]

train_malays

train_chinese["ethnic_group"].values[0]

def best_ga(train, val, max_deg_iter=31, epoches=1000):

    #births
    best_score_b = 100
    best_equ_b = object
    best_deg_b = max_deg_iter
    for deg_num in range(1, max_deg_iter):
      params = genetic_algorithm(epoches, train["live_births"].values, deg_num)
      p = np.poly1d(params)
      y = (p(train["year"].values))
      y = (p(val["year"].values))
      val_score = np.sum(np.abs(y - val["live_births"].values))/len(val["live_births"].values)
      if val_score < best_score_b:
        best_score_b = val_score
        best_equ_b = p
        best_deg_b = deg_num

    #deaths
    best_score_d = 100
    best_equ_d = object
    best_deg_d = max_deg_iter
    for deg_num in range(1, max_deg_iter):
      params = genetic_algorithm(epoches, train["deaths"].values, deg_num)
      p = np.poly1d(params)
      y = (p(train["year"].values))
      y = (p(val["year"].values))

      val_score = np.sum(np.power(y - val["deaths"].values, 2))/len(val["deaths"].values)
      # val_score = np.sum(np.abs(y - val["deaths"].values))/len(val["deaths"].values)

      if val_score < best_score_d:
        best_score_d = val_score
        best_equ_d = p
        best_deg_d = deg_num

    return best_equ_b, best_equ_d, best_deg_b, best_deg_d

max_df

def denormalize(normalized_value, mode):
  return normalized_value * (max_df[mode] - min_df[mode]) + min_df[mode]

def draw_report(train, val, test, normalized, best_equ, mode):

    fig, axs = plt.subplots(1, 2)

    y_train = (best_equ(train["year"].values))
    y_val = (best_equ(val["year"].values))
    y_test = (best_equ(test["year"].values))
    y = (best_equ(normalized["year"].values))


    
    if mode == "b":
      mode = "live_births"
    elif mode == "d":
      mode = "deaths"

    #denormalize predictions
    y_train, year_train = denormalize(y_train, mode),     denormalize(train["year"].values, "year")
    y_val, year_val =     denormalize(y_val, mode),       denormalize(val["year"].values, "year")
    y_test, year_test =   denormalize(y_test, mode),      denormalize(test["year"].values, "year")
    y, year_y =           denormalize(y, mode),           denormalize(normalized["year"].values, "year")

    #denormalize actual
    y_actual =            denormalize(train[mode].values, mode)

    axs[0].plot(year_train, y_actual,'o', label="actual")
    axs[0].plot(year_train, y_train,'*', label="predict_train")

    axs[0].plot(year_val, y_val, 'x',label="predict_val")
    axs[0].plot(year_test, y_test, '+',label="predict_test")


    axs[1].plot(year_train, y_actual,'o', label="actual")
    axs[1].plot(year_y, y ,label="predict")

    fig.set_size_inches(14, 7)

    for i in range(2):
      axs[i].set_xlabel('year')
      axs[i].set_ylabel(mode)
      axs[i].legend()
    plt.show()

def seperator():
  print("#########################################################################################################################################################################")
  print("#########################################################################################################################################################################")

if __name__ == "__main__":
  for country in ["chinese", "malays", "indians"]:
    if country == "chinese":
      seperator()
      print("Processing Chinese's data...")
      best_equ_b_chinese, best_equ_d_chinese, best_deg_b_chinese, best_deg_d_chinese = best_ga(train_chinese, val_chinese)
      print("Chinese's live-births:\nBest degree:",str(best_deg_b_chinese))
      draw_report(train_chinese, val_chinese, test_chinese, normalized_chinese, best_equ_b_chinese, "b")
      print("Chinese's deaths:\nBest degree:",str(best_deg_d_chinese))
      draw_report(train_chinese, val_chinese, test_chinese, normalized_chinese, best_equ_d_chinese, "d")
      seperator()
    elif  country == "malays":
      seperator()
      print("Processing Malays' data...")
      best_equ_b_malays, best_equ_d_malays, best_deg_b_malays, best_deg_d_malays = best_ga(train_malays, val_malays)
      print("Malays' live-births:\nBest degree:",str(best_deg_b_malays))
      draw_report(train_malays, val_malays, test_malays, normalized_malays, best_equ_b_malays, "b")
      print("Malays' deaths:\nBest degree:",str(best_deg_d_malays))
      draw_report(train_malays, val_malays, test_malays, normalized_malays, best_equ_d_malays, "d")
      seperator()
    elif  country == "indians":
      seperator()
      print("Processing Indians' data...")
      best_equ_b_indians, best_equ_d_indians, best_deg_b_indians, best_deg_d_indians = best_ga(train_indians, val_indians)
      print("Indians' live-births:\nBest degree:",str(best_deg_b_indians))
      draw_report(train_indians, val_indians, test_indians, normalized_indians, best_equ_b_indians, "b")
      print("Indians' deaths:\nBest degree:",str(best_deg_d_indians))
      draw_report(train_indians, val_indians, test_indians, normalized_indians, best_equ_d_indians, "d")
      seperator()





